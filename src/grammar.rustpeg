use super::ast::{HexNumber, DecNumber, HexLiteral, StringLiteral, LinkerSymbol,
                 Identifier, LabelDefinition, Assignment, Item,
                 FunctionalExpression, LocalDefinition, FunctionalAssignment,
                 Block, SubAssembly, Switch, Case, DefaultCase,
                 FunctionDefinition, For, ForOp, Expression};

pub block -> Block
  = __ "{" items:(item*) __ "}" { Block::new(items) }

pub item -> Item
  = __ "break" { Item::Break() }
  / __ "continue" { Item::Continue() }
  / __ "errorLabel" { Item::ErrorLabel() }
  / __ "bytecodeSize" { Item::BytecodeSize() }
  / __ "dataSize" __ "(" i:identifier __ ")" { Item::DataSize(i) }
  / x:hex_literal { Item::HexLiteral(x) }
  / d:local_definition { Item::LocalDefinition(d) }
  / s:sub { Item::SubAssembly(s) }
  / s:switch { Item::Switch(s) }
  / f:for_stmt { Item::For(f) }
  / b:block { Item::Block(b) }
  / d:function_definition { Item::FunctionDefinition(d) }
  / a:functional_assignment { Item::FunctionalAssignment(a) }
  / e:functional_expression { Item::FunctionalExpression(e) }
  / l:linker_symbol { Item::LinkerSymbol(l) }
  / i:identifier { Item::Identifier(i) }
  / a:assignment { Item::Assignment(a) }
  / l:label_definition { Item::LabelDefinition(l) }
  / x:hex_number { Item::HexNumber(x) }
  / n:dec_number { Item::DecNumber(n) }

pub functional_expression -> FunctionalExpression
  = __ i:identifier __ "(" items:item_list __ ")" { FunctionalExpression::new(i, items) }

expression -> Expression
  = e:functional_expression { Expression::FunctionalExpression(e) }
  / x:hex_number { Expression::HexNumber(x) }
  / n:dec_number { Expression::DecNumber(n) }
  / s:string { Expression::StringLiteral(s) }

pub local_definition -> LocalDefinition
  = __ "let" is:identifier_or_list __ ":=" e:expression {
      LocalDefinition::new(is, e)
    }

pub functional_assignment -> FunctionalAssignment
  = __ is:identifier_or_list __ ":=" e:functional_expression {
    FunctionalAssignment::new(is, e)
  }

pub sub -> SubAssembly
  = __ "assembly" i:identifier b:block { SubAssembly::new(i, b) }

pub switch -> Switch
  = __ "switch" e:functional_expression cs:(case*) d:(default?) { Switch::new(e, cs, d) }

pub case -> Case
  = __ "case" e:expression __ ":" b:block { Case::new(e, b) }

pub default -> DefaultCase
  = __ "default" __ ":" b:block { DefaultCase::new(b) }

pub function_definition -> FunctionDefinition
  = __ "function" i:identifier __ "(" args:identifier_list_or_empty __ ")"
      __ "->" __ "(" returns:identifier_list __ ")" block:block
    { FunctionDefinition::new(i, args, Some(returns), block) }
  / __ "function" i:identifier __ "(" args:identifier_list_or_empty __ ")" block:block
    { FunctionDefinition::new(i, args, None, block) }

for_stmt -> For
  = __ "for" init:for_op check:functional_expression each:for_op block:block {
      For::new(init, check, each, block)
    }

for_op -> ForOp
  = b:block { ForOp::Block(b) }
  / e:functional_expression { ForOp::FunctionalExpression(e) }

item_list -> Vec<Item>
  = __ first:item rest:(item_list_clause*) {
      let mut items = vec![first];
      items.extend(rest);
      items
    }
  / __ { vec![] }

item_list_clause -> Item
  = __ "," item:item { item }


pub identifier_or_list -> Vec<Identifier>
  = i:identifier { vec![i] }
  / __ "(" is:identifier_list __ ")" { is }

pub identifier_list -> Vec<Identifier>
  = __ i:identifier is:(identifier_list_clause*) {
      let mut identifiers = vec![i];
      identifiers.extend(is);
      identifiers
  }

pub identifier_list_or_empty -> Vec<Identifier>
  = opt:(identifier_list?)  {
      match opt {
        Some(identifiers) => identifiers,
        None => vec![],
      }
    }


identifier_list_clause -> Identifier
  = __ "," i:identifier { i }

pub assignment -> Assignment
  = __ "=:" i:identifier  { Assignment::new(i) }

pub label_definition -> LabelDefinition
  = i:identifier ':' { LabelDefinition::new(i) }

pub identifier -> Identifier
  = __ name:$([a-zA-Z_$] [a-zA-Z_0-9]*) { Identifier::new(name) }

pub linker_symbol -> LinkerSymbol
  = __ "linkerSymbol" "(" s:string ")" { LinkerSymbol::new(s) }

pub hex_literal -> HexLiteral
  = __ "hex" b:bytestr { HexLiteral::new(b.as_str()) }

bytestr -> String
  = __ "\"" b:bytes "\"" { b }
  / __ "\'" b:bytes "\'" { b }
bytes -> String
  = b:$(([0-9A-Fa-f]{2})*) { b.to_string() }

pub string -> StringLiteral
  = __ string:(doubleQuotedString) { StringLiteral::new(string) }

pub hex_number -> HexNumber
  = __ "0x" uint:$([0-9A-Fa-f]+) { HexNumber::new(uint) }

pub dec_number -> DecNumber
  = __ uint:$([0-9]+) { DecNumber::new(uint) }

doubleQuotedString -> String
  = __ '"' s:doubleQuotedCharacter* '"' { s.into_iter().collect() }

doubleQuotedCharacter -> char
  = simpleDoubleQuotedCharacter

simpleDoubleQuotedCharacter -> char
  = (!('"' / "\r" / "\n" / "\\") / "\\" .) c:$. { c.chars().next().unwrap() }

__ = (whitespace / comment)*

whitespace = [ \t\n\r]
comment
  = "//" (!'\n' .)*
  / "/*" (!"*/" .)* "*/"
