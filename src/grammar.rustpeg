use super::ast::*;

LBRACE          = __ "{"
RBRACE          = __ "}"
LPAREN          = __ "("
RPAREN          = __ ")"
ARROW           = __ "->"
COLON           = __ ":"
COMMA           = __ ","
LET             = __ "let"
EQUALTO         = __ ":="
BREAK           = __ "break"
CONTINUE        = __ "continue"
BYTECODESIZE    = __ "bytecodeSize"
DATASIZE        = __ "dataSize"
HEX             = __ "hex"
_X              = __ "0x"
FOR             = __ "for"
SWITCH          = __ "switch"
CASE            = __ "case"
DEFAULT         = __ "default"
ASSEMBLY        = __ "assembly"
FUNCTION        = __ "function"
LINKERSYMBOL    = __ "linkerSymbol"
DQUOTE_BEGIN    = __ "\""
DQUOTE_END      = "\""
SQUOTE_BEGIN    = __ "\'"
SQUOTE_END      = "\'"
COMMENT_LINE    = "//"
COMMENT_BEGIN   = "/*"
COMMENT_END     = "*/"

pub block -> Block
  = LBRACE statements:(statement*)? __ RBRACE {
      match statements {
        Some(ss) => Block::new(ss),
        None => Block::new(vec![]),
      }
    }

pub statement -> Statement
  = b:block { Statement::Block(b) }
  / d:function_definition { Statement::FunctionDefinition(d) }
  / o:control_op { Statement::ControlOp(o) }
  / s:switch { Statement::Switch(s) }
  / d:variable_declaration { Statement::VariableDeclaration(d) }
  / a:assignment { Statement::Assignment(a) }
  / l:label_definition { Statement::LabelDefinition(l) }  // included??
  / f:for_loop { Statement::ForLoop(f) }
  / s:sub_assembly { Statement::SubAssembly(s) }
  / d:data_size { Statement::DataSize(d) }
  / l:linker_symbol { Statement::LinkerSymbol(l) }
  / e:expression { Statement::Expression(e) }

pub expression -> Expression
  = l:literal { Expression::Literal(l) }
  / c:function_call { Expression::FunctionCall(c) }
  / i:identifier { Expression::Identifier(i) }

pub label_definition -> LabelDefinition
  = i:identifier COLON { LabelDefinition::new(i) }

pub function_definition -> FunctionDefinition
  = FUNCTION i:identifier LPAREN args:identifier_list_or_empty RPAREN
      ARROW LPAREN returns:identifier_list RPAREN block:block
    { FunctionDefinition::new(i, args, Some(returns), block) }
  / FUNCTION i:identifier LPAREN args:identifier_list_or_empty RPAREN block:block
    { FunctionDefinition::new(i, args, None, block) }

identifier_list_or_empty -> Vec<Identifier>
  = opt:(identifier_list?)  {
      match opt {
        Some(identifiers) => identifiers,
        None => vec![],
      }
    }

identifier_list -> Vec<Identifier>
  = i:identifier is:(identifier_list_clause*) {
      let mut identifiers = vec![i];
      identifiers.extend(is);
      identifiers
  }

identifier_list_clause -> Identifier
  = COMMA i:identifier { i }

pub variable_declaration -> VariableDeclaration
  = LET is:identifier_or_list EQUALTO e:expression {
      VariableDeclaration::new(is, e)
    }

identifier_or_list -> Vec<Identifier>
  = LPAREN is:identifier_list RPAREN { is }
  / i:identifier { vec![i] }

pub assignment -> Assignment
  = is:identifier_or_list EQUALTO e:expression {
    Assignment::new(is, e)
  }

pub switch -> Switch
  = SWITCH e:expression cs:(case*) d:(default?) { Switch::new(e, cs, d) }

pub case -> Case
  = CASE e:expression COLON b:block { Case::new(e, b) }

pub default -> Block
  = DEFAULT COLON b:block { b }

pub for_loop -> ForLoop
  = FOR init:block condition:expression post:block body:block {
      ForLoop::new(init, condition, post, body)
    }

pub control_op -> ControlOp
  = BREAK { ControlOp::Break() }
  / CONTINUE { ControlOp::Continue() }
  / BYTECODESIZE { ControlOp::BytecodeSize() }

pub data_size -> DataSize
  = DATASIZE LPAREN i:identifier RPAREN { DataSize::new(i) }

pub sub_assembly -> SubAssembly
  = ASSEMBLY i:identifier b:block { SubAssembly::new(i, b) }

pub function_call -> FunctionCall
  = i:identifier LPAREN ss:statement_list RPAREN { FunctionCall::new(i, ss) }

statement_list -> Vec<Statement>
  = first:statement rest:(statement_list_clause*) {
      let mut statements = vec![first];
      statements.extend(rest);
      statements
    }
  / { vec![] }

statement_list_clause -> Statement
  = COMMA s:statement { s }

pub linker_symbol -> LinkerSymbol
  = LINKERSYMBOL LPAREN s:string_literal RPAREN { LinkerSymbol::new(s) }

pub identifier -> Identifier
  = __ name:$([a-zA-Z_$] [a-zA-Z_0-9]*) { Identifier::new(name) }

pub literal -> Literal
  = x:hex_number { Literal::HexNumber(x) }
  / n:dec_number { Literal::DecNumber(n) }
  / l:string_literal { Literal::StringLiteral(l) }
  / l:hex_literal { Literal::HexLiteral(l) }

pub string_literal -> StringLiteral
  = __ string:(double_quoted_string) { StringLiteral::new(string) }

double_quoted_string -> String
  = DQUOTE_BEGIN s:double_quoted_character* DQUOTE_END { s.into_iter().collect() }

double_quoted_character -> char
  = (!('"' / "\r" / "\n" / "\\") / "\\" .) c:$. { c.chars().next().unwrap() }

pub hex_literal -> HexLiteral
  = HEX b:bytestr { HexLiteral::new(b.as_str()) }

bytestr -> String
  = DQUOTE_BEGIN b:bytes DQUOTE_END { b }
  / SQUOTE_BEGIN b:bytes SQUOTE_END { b }

bytes -> String
  = b:$(([0-9A-Fa-f]{2})*) { b.to_string() }

pub hex_number -> HexNumber
  = _X uint:$([0-9A-Fa-f]+) { HexNumber::new(uint) }

pub dec_number -> DecNumber
  = __ uint:$([0-9]+) { DecNumber::new(uint) }

__ = (whitespace / comment)*

whitespace = [ \t\n\r]
comment
  = COMMENT_LINE (!'\n' .)*
  / COMMENT_BEGIN (!COMMENT_END .)* COMMENT_END
