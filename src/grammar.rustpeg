use super::ast::{HexNumber, DecNumber, HexLiteral, StringLiteral, LinkerSymbol,
                 Identifier, LabelDefinition, Assignment, Item,
                 FunctionalExpression, LocalDefinition, FunctionalAssignment,
                 Block, SubAssembly};

pub block -> Block
  = __ "{" items:(item*) { Block::new(items) }

pub item -> Item
  = "break" { Item::Break() }
  / "continue" { Item::Continue() }
  / "errorLabel" { Item::ErrorLabel() }
  / "bytecodeSize" { Item::BytecodeSize() }
  / "dataSize" "(" i:identifier ")" { Item::DataSize(i) }
  / x:hex_literal { Item::HexLiteral(x) }
  / d:local_definition { Item::LocalDefinition(d) }
  / s:sub { Item::SubAssembly(s) }

  / b:block { Item::Block(b) }
  / a:functional_assignment { Item::FunctionalAssignment(a) }
  / e:functional_expression { Item::FunctionalExpression(e) }
  / l:linker_symbol { Item::LinkerSymbol(l) }
  / i:identifier { Item::Identifier(i) }
  / a:assignment { Item::Assignment(a) }
  / l:label_definition { Item::LabelDefinition(l) }
  / x:hex_number { Item::HexNumber(x) }
  / n:dec_number { Item::DecNumber(n) }

pub functional_expression -> FunctionalExpression
  = __ i:identifier "(" items:item_list ")" { FunctionalExpression::new(i, items) }

pub local_definition -> LocalDefinition
  = __ "let" is:identifier_or_list __ ":=" e:functional_expression {
      LocalDefinition::new(is, e)
    }

pub functional_assignment -> FunctionalAssignment
  = __ is:identifier_or_list __ ":=" e:functional_expression {
    FunctionalAssignment::new(is, e)
  }

pub sub -> SubAssembly
  = __ "assembly" i:identifier b:block { SubAssembly::new(i, b) }


item_list -> Vec<Item>
  = __ first:item rest:(item_list_clause*) {
      let mut items = vec![first];
      items.extend(rest);
      items
    }
  / __ { vec![] }

item_list_clause -> Item
  = __ "," item:item { item }


pub identifier_or_list -> Vec<Identifier>
  = __ i:identifier { vec![i] }
  / __ "(" is:identifier_list ")" { is }

pub identifier_list -> Vec<Identifier>
  = __ i:identifier is:(identifier_list_clause*) {
      let mut identifiers = vec![i];
      identifiers.extend(is);
      identifiers
  }

identifier_list_clause -> Identifier
  = __ "," i:identifier { i }

pub assignment -> Assignment
  = "=:" i:identifier  { Assignment::new(i) }

pub label_definition -> LabelDefinition
  = __ i:identifier ':' { LabelDefinition::new(i) }

pub identifier -> Identifier
  = __ name:$([a-zA-Z_$] [a-zA-Z_0-9]*) { Identifier::new(name) }

pub linker_symbol -> LinkerSymbol
  = __ "linkerSymbol" "(" s:string ")" { LinkerSymbol::new(s) }

pub hex_literal -> HexLiteral
  = __ "hex" b:bytestr { HexLiteral::new(b.as_str()) }

bytestr -> String
  = "\"" b:bytes "\"" { b }
  / "\'" b:bytes "\'" { b }
bytes -> String
  = b:$(([0-9A-Fa-f]{2})*) { b.to_string() }

pub string -> StringLiteral
  = __ string:(doubleQuotedString) { StringLiteral::new(string) }

pub hex_number -> HexNumber
  = __ "0x" uint:$([0-9A-Fa-f]+) { HexNumber::new(uint) }

pub dec_number -> DecNumber
  = __ uint:$([0-9]+) { DecNumber::new(uint) }

doubleQuotedString -> String
  = '"' s:doubleQuotedCharacter* '"' { s.into_iter().collect() }

doubleQuotedCharacter -> char
  = simpleDoubleQuotedCharacter

simpleDoubleQuotedCharacter -> char
  = (!('"' / "\r" / "\n" / "\\") / "\\" .) c:$. { c.chars().next().unwrap() }

__ = (whitespace / comment)*

whitespace = [ \t\n\r]
comment
  = "//" (!'\n' .)*
  / "/*" (!"*/" .)* "*/"
